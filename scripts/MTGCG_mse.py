# File: MTGCG-mse.py
# Description: Converts Magic: The Gathering card data generated by MTGCG API
#              into Magic Set Editor (MSE) compatible format.
# Author: Merlin Duty-Knez
# Created: [2025-07-29]
# Dependencies: Python 3.8+, requests, json
# Usage:
#     python MTGCG-mse.py
#
# Notes:
# - This parser expects input in MTGCG API JSON format.
# - Outputs data structured for use in MSE (Magic Set Editor) .mse-set format.
# - Validates fields, maps MTGCG keys to MSE keys, and sanitizes special characters.
# - Designed to be extensible for custom card attributes and rules text.

# MTGCG-mse.py
import json
from datetime import datetime

import logging

import zipfile
import os

import shutil

from dotenv import load_dotenv
# Load environment variables from .env file
load_dotenv()

import yaml

import urllib.request

import time
from openai import OpenAI

# Handle imports for both direct execution and module import
try:
    from . import imagesSD
    from . import config_manager
except ImportError:
    # When running directly (not as a module)
    import imagesSD
    import config_manager

from tqdm import tqdm
from tqdm.contrib.logging import logging_redirect_tqdm

from concurrent.futures import ThreadPoolExecutor, as_completed

# Logging setup - respect orchestrator's verbose setting
def setup_logging():
    """Setup logging based on environment variable from orchestrator."""
    verbose = os.environ.get("MERLIN_VERBOSE", "1") == "1"
    if verbose:
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s - %(levelname)s - %(message)s",
            force=True
        )
    else:
        # Suppress all logs except errors in quiet mode
        logging.basicConfig(
            level=logging.WARNING,
            format="%(message)s",
            force=True
        )

# Don't call setup_logging() at import time - let it be called when needed

# NOTE: Configuration now loaded via config_manager instead of global loading
# Global constants only
API_KEY = os.getenv("API_KEY")

# TODO: These will be set dynamically in main() - should be refactored to pass as parameters
# Module-level variables (will be set by main)
max_retries = None
retry_delay = None
timeout = None
image_method = None
model_swap_chance = None
sleepy_time = None
concurrency = None

BAR_FMT = (
    "{desc}: {percentage:3.0f}%|{bar}| {n_fmt}/{total_fmt} "
    "[Elapsed: {elapsed} | Remaining: {remaining} | Avg: {rate_fmt}]"
)


# --- CONFIGURABLE STATIC HEADER ---
HEADER_TEMPLATE = """mse_version: 2.0.2
game: magic
game_version: 2024-10-01
stylesheet: m15-altered
stylesheet_version: 2024-09-23
set_info:
	symbol: 
	masterpiece_symbol: 
	automatic_reminder_text: 
	sort_multicolor_in_pairs: yes
	sort_hybrid_in_pairs: yes
styling:
	magic-m15-altered:
		text_box_mana_symbols: magic-mana-small.mse-symbol-font
		level_mana_symbols: magic-mana-large.mse-symbol-font
		overlay: 
	magic-m15-mainframe-dfc:
		text_box_mana_symbols: magic-mana-small.mse-symbol-font
		level_mana_symbols: magic-mana-large.mse-symbol-font
		overlay: 
	magic-m15-mainframe-planeswalker:
		text_box_mana_symbols: magic-mana-small.mse-symbol-font
		overlay: 
"""

def ask_overlord_for_loyalty(index: int, card: dict, ai: OpenAI):

    if ai is None:
        ai = OpenAI(api_key=API_KEY)

    loyalty = 0

    card_data = {
        "name": card["name"],
        "manaCost": card["manaCost"],
        "typeLine": card["typeLine"],
        "oracleText": card["oracleText"],
        "colorIdentity": card["colorIdentity"],
        "rarity": card["rarity"],
    }

    input = [
        {
            "role": "system",
            "content": "You are an assistant who works as a Magic: The Gathering card designer. You review Planeswalker cards and propose their starting Loyalty. OUTPUT MUST BE A SINGLE INTEGER EQUAL TO THE PROPOSED STARTING LOYALTY. DO NOT EXPLAIN THE CARD OR YOUR REASONING IN YOUR FINAL OUTPUT. The output must follow Magic the Gathering card power balancing principles",
        },
        {"role": "user", "content": json.dumps(card_data)},
    ]

    for attempt in range(1, max_retries + 1):
        try:
            response = ai.responses.create(
                model="gpt-5",
                input=input,
                timeout=timeout
            )
            if response.status in ['failed', 'cancelled']:
                raise response
            break  # Exit loop if request succeeded
        except Exception as e:
            logging.error(f"[Card #{index+1}] Attempt {attempt} failed: {e}")
            if attempt == max_retries:
                raise # Re-raise last exception if all retries failed
            time.sleep(retry_delay)  # Wait before retrying

    # Check if the request was successful
    if response.status == "completed":
        logging.debug(f"[Card #{index+1}] Response from OpenAI: {response.model_dump()}")
        loyalty = response.model_dump()["output"][1]["content"][0]["text"]
        logging.info(f"[Card #{index+1}] Overlord says Loyalty: {loyalty}")
        time.sleep(sleepy_time)

    else:
        logging.info(f"[Card #{index+1}] Error:{response.status}, {response.text}")
        time.sleep(sleepy_time)

    return loyalty

def card_to_mse_block(index: int, card: dict, ai: OpenAI):
    # Extracting fields from the card JSON
    name = card.get("name", "Unknown Card")

    logging.info(f"[Card #{index+1}] Adding card: {name}")
    time.sleep(sleepy_time)

    image_noext = card.get("id", "")
    manaCost = card.get("manaCost", "")
    typeLine = card.get("typeLine", "")
    if "\u2014" in typeLine:
        supertype = typeLine.split("\u2014")[0].strip()
        subtype = typeLine.split("\u2014")[1].strip()
    else:
        supertype, subtype = typeLine, ""
    colorIdentity = card.get("colorIdentity", "")
    rarity = card.get("rarity").lower()
    oracle = card.get("oracleText", "")
    flavour = card.get("flavorText") or ""
    pt = (
        card.get("pt", "")
        .replace("Starting Loyalty: ", "")
        .replace("Loyalty: ", "")
        .replace("None", "")
        .replace(":", "")
        .strip()
    )

    if "Planeswalker" in typeLine and pt == "":
        logging.info(f"[Card #{index+1}] Found Planeswalker with not P/T -- Interpreting rules text for loyalty counters.")
        time.sleep(sleepy_time)
        texts = [
            "{iname} enters the battlefield with {iloyalty} loyalty counters.",
            "{iname} enters the battlefield with {iloyalty} Loyalty counters.",
            "Starting Loyalty: {iloyalty}",
            "Starting loyalty: {iloyalty}",
            "Loyalty: {iloyalty}",
        ]
        for loyalty in range(100):
            for text in texts:
                text = text.format(iname=name, iloyalty=loyalty)
                logging.debug(f"[Card #{index+1}] Looking for '{text}' in oracle text ")
                if text in oracle:
                    logging.info(
                        f"[Card #{index+1}] Found '{text}' in oracle text"
                    )
                    time.sleep(sleepy_time)
                    oracle = oracle.replace(text, "").strip()
                    pt = f"{loyalty}"
                    break
            else:
                continue  # only executed if the inner loop did NOT break
            break  # only executed if the inner loop DID break

        else:

            logging.info(f"[Card #{index+1}] Could not interpret loyalty from oracle text. Asking AI Overlord instead")
            time.sleep(sleepy_time)
            pt = ask_overlord_for_loyalty(index, card, ai=ai)

    if "/" in pt:
        power, toughness = pt.split("/") if pt else ("", "")
    else:
        power = pt
        toughness = ""
    dt = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Create text for the MSE block
    block = f"""card:
	has_styling: true
	styling_data:
		text_box_mana_symbols: magic-mana-small.mse-symbol-font
		level_mana_symbols: magic-mana-large.mse-symbol-font
		overlay: 
	notes:
		raw:
		{name}
		{manaCost}
		{typeLine}
		{colorIdentity}
		{rarity}
		{oracle.replace("\n", "\n\t\t")}
		{flavour.replace("\n", "\n\t\t")}
		({pt})
	time_created: {dt}
	time_modified: {dt}
	name: {name}
	casting_cost: {manaCost.replace("{", "").replace("}", "")}
	image: {image_noext}.png
	image_2: 
	mainframe_image: 
	mainframe_image_2: 
	super_type: <word-list-type-en>{supertype}</word-list-type-en>
	sub_type: <word-list-type-en>{subtype}</word-list-type-en>
	rarity: {rarity}
	rule_text:
		{oracle.replace("\n\n","\n").replace("\n", "\n\t\t").replace("{", "[").replace("}", "]").replace("âˆ’", "-")}
	flavor_text:
		{flavour.replace("\n", "\n\t\t")}
	power: {power}
	toughness: {toughness}
	card_code_text: 
	card_code_text_2: 
	card_code_text_3: 
	copyright: 
	copyright_2: 
"""

    return block


def convert_cards(json_cards, ai=None):
    """
    Threaded converter with order-preserving assembly.
    Falls back to single-thread if concurrency <= 1.
    """
    total = len(json_cards)
    

    # Single-thread fast path (keeps your original behavior)
    if concurrency <= 1:
        parts = [HEADER_TEMPLATE]
        for i, card in enumerate(
            tqdm(json_cards, desc="Add mse card blocks", unit="card", bar_format=BAR_FMT, dynamic_ncols=True)
        ):
            parts.append(card_to_mse_block(i, card, ai=ai))
        return "".join(parts)

    # Threaded path
    results = [None] * total  # index-aligned storage to preserve order

    def _worker(i, card):
        # Pass ai=None so ask_overlord_for_loyalty creates a client per thread when needed
        return i, card_to_mse_block(i, card, ai=None)

    with tqdm(total=total, desc="Add mse card blocks", unit="card", bar_format=BAR_FMT, dynamic_ncols=True) as pbar:
        with ThreadPoolExecutor(max_workers=concurrency) as ex:
            futures = [ex.submit(_worker, i, card) for i, card in enumerate(json_cards)]
            for fut in as_completed(futures):
                i, block = fut.result()  # let exceptions surface; your main already logs nicely
                results[i] = block
                pbar.update(1)

    return HEADER_TEMPLATE + "".join(results)

def download_images(cards, output_dir, on_done=None):
    """
    Concurrent image downloader.
    - Respects config['aitomaton_config']['concurrency'] if present.
    - Calls on_done(1) once per card (even on failure or missing URL).
    """
    os.makedirs(output_dir, exist_ok=True)
    # TODO: Should accept config as parameter instead of using globals
    # Use your existing HTTP timeout if set; fall back to 60s
    http_timeout = timeout

    def _worker(i_card):
        i, card = i_card
        name = card.get("name", f"#{i+1}")
        logging.info(f"[#{i+1}] Downloading image for {name}...")
        try:
            time.sleep(sleepy_time)  # keep your throttle if desired
            image_url = card.get("imageUrl")
            if not image_url:
                logging.warning(f"[#{i+1}] No image URL found for {name}. Skipping.")
                return False

            image_path = os.path.join(output_dir, f"{card['id']}.png")

            # Stream and save with a per-request timeout
            req = urllib.request.Request(image_url)
            with urllib.request.urlopen(req, timeout=http_timeout) as resp, open(image_path, "wb") as out:
                out.write(resp.read())

            return True
        except Exception as e:
            logging.error(f"[#{i+1}] Failed to download image for {name}: {e}")
            return False

    # Submit all tasks
    with ThreadPoolExecutor(max_workers=concurrency) as ex:
        futures = [ex.submit(_worker, (i, card)) for i, card in enumerate(cards)]
        for fut in as_completed(futures):
            # ensure the outer progress bar advances once per card
            if on_done:
                try:
                    on_done(1)
                except Exception:
                    # don't let a callback error kill the loop
                    pass
            # surface exceptions if you want to crash on unexpected errors:
            # _ = fut.result()

def _move_generated(cards, src_dir: str, dst_dir: str) -> None:
    os.makedirs(dst_dir, exist_ok=True)
    for card in cards:
        src = os.path.join(src_dir, f"{card['id']}.png")
        dst = os.path.join(dst_dir, f"{card['id']}.png")
        if not os.path.exists(src):
            logging.warning(f"Image for {card['name']} not found in {src_dir}.")
            continue
        try:
            shutil.move(src, dst)
            logging.info(f"Moved image for {card['name']} to {dst}")
            time.sleep(sleepy_time)
        except Exception as e:
            logging.error(f"Failed to move image for {card['name']}: {e}")

def _handle_download(cards, output_dir, on_done):
    logging.info("Using download method for image retrieval.")
    time.sleep(sleepy_time)
    download_images(cards, output_dir, on_done=on_done)

def _handle_localsd(cards, output_dir, on_done, config):
    logging.info("Using local SD for image generation.")
    time.sleep(sleepy_time)
    out_dir = imagesSD.generate_images_from_dict(
        cards,
        config,  # Pass config to imagesSD
        option_change_chance=model_swap_chance,
        on_done=on_done,  # overall bar ticks as each image finishes
    )
    _move_generated(cards, src_dir=out_dir, dst_dir=output_dir)

def _handle_none(cards, output_dir, on_done):
    logging.info("Skipping image download as per configuration.")
    time.sleep(sleepy_time)
    # still complete the bar so UX matches "no work to do"
    for _ in cards:
        on_done()

def get_images(cards, output_dir, method="download", config=None):
    total = len(cards)
    with tqdm(total=total, desc="Images", unit="img",
              dynamic_ncols=True, bar_format=BAR_FMT, position=1) as pbar:

        def mark_done(_=None):
            pbar.update(1)

        handlers = {
            "download": lambda c, o, d: _handle_download(c, o, d),
            "localSD": lambda c, o, d: _handle_localsd(c, o, d, config),
            "none": lambda c, o, d: _handle_none(c, o, d),
        }

        handler = handlers.get(method)
        if handler is None:
            raise ValueError(f"Unknown image retrieval method: {method}")

        try:
            handler(cards, output_dir, mark_done)
        except Exception as e:
            logging.error(f"Error in get_images ({method}): {e}")


def export_to_zip(output_text, cards, image_method="download", output_dir="output/mse-out", filename="set", config=None, config_name=None):
    os.makedirs(output_dir, exist_ok=True)
    set_path = os.path.join(output_dir, filename)
    with open(set_path, "w", encoding="utf-8") as f:
        f.write(output_text)
    get_images(cards, output_dir, method=image_method, config=config)
    
    # Create zip filename with config name prefix if provided
    if config_name:
        zip_filename = os.path.join(os.path.dirname(output_dir), f"{config_name}-{os.path.basename(output_dir)}.mse-set")
    else:
        zip_filename = f"{output_dir}.mse-set"
        
    with zipfile.ZipFile(zip_filename, "w", zipfile.ZIP_DEFLATED) as zipf:
        for root, _, files in os.walk(output_dir):
            for file in files:
                file_path = os.path.join(root, file)
                arcname = os.path.relpath(file_path, output_dir)
                zipf.write(file_path, arcname=arcname)
    
    # Clean up the mse-out directory after successful zipping
    try:
        shutil.rmtree(output_dir)
        logging.info(f"Cleaned up temporary directory: {output_dir}")
    except Exception as e:
        logging.warning(f"Failed to clean up temporary directory {output_dir}: {e}")


def main_with_config(config_path=None, config=None):
    """Main function that loads config and runs the MSE conversion."""
    global max_retries, retry_delay, timeout, image_method, model_swap_chance, sleepy_time, concurrency
    
    if config_path is None:
        config_path = "configs/user.yml"
    
    if config is None:
        config = config_manager.load_config(config_path)
    
    # Extract config filename for input naming
    config_name = os.path.splitext(os.path.basename(config_path))[0]
    
    # Extract config values (no fallbacks - values guaranteed by config validation)
    max_retries = config["http_config"]["retries"]
    retry_delay = config["http_config"]["retry_delay"]
    timeout = config["http_config"]["timeout"]
    image_method = config["mtgcg_mse_config"]["image_method"]
    model_swap_chance = config["SD_config"]["model_swap_chance"]
    sleepy_time = config["aitomaton_config"]["sleepy_time"]
    concurrency = int(config["aitomaton_config"]["concurrency"])
    
    with logging_redirect_tqdm():
        outdir = config["aitomaton_config"]["output_dir"]
        config_outdir = os.path.join(outdir, config_name)
        cardsjson = os.path.join(config_outdir, f"{config_name}-cards.json")
        
        if not os.path.exists(cardsjson):
            logging.error(f"Cards file not found: {cardsjson}")
            logging.error("Please run square_generator.py first to generate cards.")
            return
        
        with open(cardsjson, "r", encoding="utf-8") as f:
            cards_data = json.load(f)

        logging.info(f"Loaded {len(cards_data)} cards from {cardsjson}")

        openai_client = None

        logging.info("=== Starting conversion ===")
        time.sleep(sleepy_time)
        mse_output = convert_cards(cards_data, ai=openai_client)

        mse_outpath = os.path.join(config_outdir, "mse-out")
        
        # Clean up previous mse-out directory to prevent accumulation of old images
        if os.path.exists(mse_outpath):
            logging.info(f"Cleaning up previous mse-out directory: {mse_outpath}")
            shutil.rmtree(mse_outpath)
            time.sleep(sleepy_time)

        # Extract config name for file prefixing (remove path and extension)
        config_name = os.path.splitext(os.path.basename(config_path))[0]

        logging.info("=== Exporting to .mse-set ===")
        time.sleep(sleepy_time)
        export_to_zip(
            mse_output,
            cards_data,
            image_method=image_method,
            output_dir=mse_outpath,
            filename="set",
            config=config,
            config_name=config_name
        )

        # Calculate the zip filename for logging (same logic as in export_to_zip)
        zip_filename = os.path.join(config_outdir, f"{config_name}-{os.path.basename(mse_outpath)}.mse-set")
        logging.info(f"Packaged set into {zip_filename}")
        time.sleep(sleepy_time)
        logging.info("=== Conversion complete ===")
        time.sleep(sleepy_time)

if __name__ == "__main__":
    # Load configuration using new config system with proper argument parsing
    import argparse
    
    parser = argparse.ArgumentParser(description="Convert MTG Card Generator JSON to MSE (Magic Set Editor) format")
    parser.add_argument("config", nargs="?", default="configs/user.yml", 
                       help="Path to configuration file (default: configs/user.yml)")
    parser.add_argument("--output-dir", help="Override output directory")
    
    args = parser.parse_args()
    config_path = args.config
    
    # Load and apply overrides if needed
    config = config_manager.load_config(config_path)
    if args.output_dir:
        config["aitomaton_config"]["output_dir"] = args.output_dir
    
    main_with_config(config_path, config)
